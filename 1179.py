# ॥ श्री गणेशाय नमः ॥
import math

# import odespy
# import numpy as np


# def f(u, t, w=1):
#     # v, u numbering for EulerCromer to work well
#     v, u = u  # u is array of length 2 holding our [v, u]
#     return [-w**2*u, v]


# def run_solvers_and_plot(solvers, timesteps_per_period=20, num_periods=1, I=1, w=2*np.pi):
#     P = 2*np.pi/w  # duration of one period
#     dt = P/timesteps_per_period
#     Nt = num_periods*timesteps_per_period
#     T = Nt*dt
#     t_mesh = np.linspace(0, T, Nt+1)
#     legends = []
#     for solver in solvers:
#         solver.set(f_kwargs={'w': w})
#         solver.set_initial_condition([0, I])
#         u, t = solver.solve(t_mesh)


# solvers = [
#     odespy.ForwardEuler(f),
#     # Implicit methods must use Newton solver to converge
#     odespy.BackwardEuler(f, nonlinear_solver='Newton'),
#     odespy.CrankNicolson(f, nonlinear_solver='Newton'),
# ]

# Sunil Gudurvalmiki, Sr. Director of Product Management, Cisco Data Center Networking.

print(math.pi)

print(2**7)


print(math.e)


# ॥ जय श्री राम जय श्री कृष्ण ॥
